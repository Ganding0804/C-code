#include <stdio.h>
#include <stdlib.h>

/*
//表达式求值中的隐式类型转换
//1.整型提升
int main()
{
    //a和b的值被提升为普通整型，然后再执行加法运算。
    //加法运算完成之后，结果将被截断，然后再存储于a中
    char a=3;
    //00000000000000000000000000000011
    //00000011 - a
    char b=127;
    //00000000000000000000000001111111
    //01111111 - b

    //a和b如何相加
    //整型提升是按照变量的数据类型的符号位来提升的
    //负整数高位补1，正整数高位补0
    //00000011 - 00000000000000000000000000000011
    //01111111 - 00000000000000000000000001111111
    //结果为00000000000000000000000010000010
    //截断后为10000010 - c
    char c=a+b;
    //整型提升11111111111111111111111110000010 - 补码
    //        11111111111111111111111110000001 - 反码
    //        10000000000000000000000001111110 - 原码
    printf("%d\n",c);//-126
    return 0;
}

//实例一
int main()
{
    char a=0xb6;
    short b=0xb600;
    int c=0xb6000000;
    if(a==0xb6)  //这里a要先进行整型提升才能比较，显然不相等了
        printf("a");
    if(b==0xb600)
        printf("b");
    if(c==0xb6000000)  //c本来就是整型，所以c会被打印出来
        printf("c");
    return 0;

}
//这里就很好的证明了整型提升的存在

//实例二
int main()
{
    char c=1;
    //%u是输入输出格式说明符，表示按unsigned int格式输入或输出数据
    printf("%u\n",sizeof(c));  //c是char类型，在内存中只占1个字节
    printf("%u\n",sizeof(+c));  //这里+c，c参与了运算，所以c被整型提升了，而整型占4个字节
    printf("%u\n",sizeof(!c));  //同上
    return 0;
}
*/

/*
2.算术转换
    如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
型，否则操作就无法进行。下面的层次体系称为寻常算术转换
    long double
    double
    float
    unsigned long int
    long int
    unsigned int
    int
    如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算
警告： 但是算术转换要合理，要不然会有一些潜在的问题

int main()
{
    float f=3.14;
    int num=f;  //隐式转换会有精度丢失
    printf("%d",num);  //3
    return 0;
}
*/

/*
操作符的属性
1.操作符的优先级（相邻不同操作符的计算顺序）
2.操作符的结合性（相邻相同符号的计算顺序）
3.是否控制求值顺序
*/
int main()
{
    int a=10;
    int b=20;
    int c=b+a*3;
    printf("%d",c);
    return 0;
}
//不要写过于复杂的表达式，不然很可能成为问题表达式，即不是唯一确定计算路径的表达式
//我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的






